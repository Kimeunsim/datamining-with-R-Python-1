
---
title: "HW1"

output:
  pdf_document:  # 출력 형식
    latex_engine: xelatex  # LaTeX 엔진 지정
    fig_caption: true  # 그림 캡션 활성화
fontsize: 12pt  # 글꼴 크기 설정
geometry: margin=1in  # 페이지 여백 설정
mainfont: "NanumGothic"  # 본문 폰트 지정 (XeLaTeX에서 폰트 지정)
header-includes:
  - \usepackage{amsmath}  # 추가적인 LaTeX 패키지 로드
---

---

```{r}
library(knitr)

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
1.	다음 물음에 답하시오.

(a)	x <- c(1,2,3,5,6,7,8,9) 이 vector에서 3으로 나눈 나머지가 0인 모든 원소를 찾는 R code를 쓰시오.
```{r}
x <- c(1,2,3,5,6,7,8,9)
x[x%%3==0]

```

(b)	b <- c(1:12) 다음과 같이 정의한 vector에서 첫번째 원소, 7번째 원소, 12번째 원소를 선택하여 myv란 vector로 정의하는 코드를 작성하시오.
```{r}

b <- c(1:12)
myv=b[c(1,7,12)]

myv
```

(c)	x <- c(-7, 0, 4, -1, 74, 3, -5) 이 vector의 원소 중에 -1보다 작거나 같거나 또는 5보다 큰 모든 원소를 가져오는 코드를 쓰시오.

```{r}

x <- c(-7, 0, 4, -1, 74, 3, -5)
x[x<=-1|x>5]


```

(d)	다음과 같이 정의된 두가지 vector가 있다.
g <- c('f','m','m','m','f','m','f','m','f','f')
a <- factor(c('adult','adult','juvenile','juvenile','adult','adult',
              'adult','juvenile','adult','juvenile'))

위의 그림과 같은 결과가 나오는 코드를 쓰시오.

```{r}

g <- c('f','m','m','m','f','m','f','m','f','f')
a <- factor(c('adult','adult','juvenile','juvenile','adult','adult','adult','juvenile','adult','juvenile'))

table(a,g)# 빈도수 
```


(e)	다음과 같이 두 벡터가 있다. 
a<-c(2,4,6,,8,10)
b<-c(1,3,5,7,9) 
이 두 벡터를 결합하여 하나의 벡터 combined로 만들고, 오름차순으로 정렬하는 코드를 작성하시오.

```{r}

a<-c(2,4,6,8,10)
b<-c(1,3,5,7,9)
combined=c(a,b)
sort(combined,decreasing=FALSE)

```
(f)	x <- c(12, 5, NA, 18, 7, NA, 3, 20, 15) 벡터 x에서 NA 값을 제거하는 코드를 작성하시오. 또한, 벡터 x의 평균을 계산하되, NA 값을 무시하고 계산하는 코드를 작성하시오.
```{r}
x <- c(12, 5, NA, 18, 7, NA, 3, 20, 15)
print(x[!is.na(x)])
print(mean(x,na.rm=TRUE))


```


(g)	다음과 같이 정의된 리스트가 있다.
my_list <- list(name = "Alice", age = 25, scores = c(85, 90, 88))
my_list에서 scores 만 추출하여 my_score라는 벡터로 저장하는 코드를 작성하시오.

```{r}
my_list <- list(name = "Alice", age = 25, scores = c(85, 90, 88))

my_score=my_list$scores
my_score
```


2.	다음 물음에 답하시오.

(a)	다음 세 개의 벡터를 이용하여 데이터 프레임 employee_data를 생성하는 코드를 작성하시오.
employees <- c("Alice", "Bob", "Charlie", "David", "Eva", "Frank", "Grace", "Hannah", "Ivan", "Julia", "Kevin", "Laura", "Michael", "Nina", "Oscar", "Paul", "Quinn", "Rachel", "Steve", "Tina")
salaries <- c(50000, 60000, 55000, 70000, 62000, 58000, 54000, 75000, 67000, 52000, 59000, 68000, 71000, 55000, 64000, 50000, 66000, 72000, 75000, 61000)
departments <- factor(c("HR", "Finance", "IT", "Marketing", "Finance", "IT", "HR", "Marketing", "Finance", "HR", "Marketing", "Finance", "IT", "HR", "Marketing", "Finance", "IT", "Finance", "HR", "IT"))

```{r}
employees <- c("Alice", "Bob", "Charlie", "David", "Eva", "Frank", "Grace", "Hannah", "Ivan", "Julia", "Kevin", "Laura", "Michael", "Nina", "Oscar", "Paul", "Quinn", "Rachel", "Steve", "Tina")
salaries <- c(50000, 60000, 55000, 70000, 62000, 58000, 54000, 75000, 67000, 52000, 59000, 68000, 71000, 55000, 64000, 50000, 66000, 72000, 75000, 61000)
departments <- factor(c("HR", "Finance", "IT", "Marketing", "Finance", "IT", "HR", "Marketing", "Finance", "HR", "Marketing", "Finance", "IT", "HR", "Marketing", "Finance", "IT", "Finance", "HR", "IT"))

employee_data=data.frame(employees=employees,salaries=salaries,departments=departments)
```

(b)	employee_data에서 각 부서별로 직원의 평균 급여를 계산하는 코드를 작성하시오.
```{r}


aggregate(salaries~departments,data=employee_data,FUN=mean)

```

(c)	Salaries의 최대값과 최소값을 찾고, 해당하는 직원의 이름을 출력하는 코드를 작성하시오.
```{r}
max_employeer=employee_data$employees[which.max(employee_data$salaries)]
min_employeer=employee_data$employees[which.min(employee_data$salaries)]
print(max_employeer)
print(min_employeer)
```

(d)	각 부서별 급여의 분포를 나타내는 plot을 그리는 코드를 작성하고, 그 그림을 그리시오.

```{r}
plot(x=employee_data$departments,y=employee_data$salaries)

```
```{r}
library(ggplot2)

ggplot(employee_data,aes(x=departments,y=salaries))+geom_boxplot(fill="lightblue",color="black")+labs(title="부서별 급여분포",x="부서",y="급여")+theme_minimal()

```

(e)	Salaries 변수를 이용하여 세금 공제 후 급여를 나타내는 파생변수를 net_salary하는 이름으로 데이터프레임에 추가하는 코드를 작성하시오. (단, 세금은 급여의 20%로 가정합니다.)
```{r}


employee_data$net_salary=employee_data$salaries*0.8
employee_data

```


(f)	departments 변수에 따라 파생 변수 is_finance를 생성하고, departments가 "Finance"인 경우 1, 아닌 경우 0을 가지도록 하세요.

```{r}
employee_data$is_finance=ifelse(employee_data$departments=="Finance",1,0)
employee_data

```

(g)	어느 부서의 평균 급여가 가장 높은지 그 이유를 적절한 코드와 결과를 통해 서술하시오.

```{r}
dep_ave=aggregate(salaries~departments,data=employee_data,FUN=mean)
dep_ave[which.max(dep_ave$salaries),]

#앞에서 계산했던 부서별 평균월급을 aggregate함수를 사용하여 계산했습니다. 이 데이터를 가지고 salaries가 max인 부서의 이름은 marketing으로 나옵니다.  

```

(h)	부서별로 급여의 분포가 어떻게 다른지 box plot을 이용하여 설명하시오.
```{r}
ggplot(employee_data,aes(x=departments,y=salaries))+geom_boxplot(fill="lightblue",color="black")+labs(title="부서별 급여분포",x="부서",y="급여")+theme_minimal()

```
##상자에서와 같이 부서별 급여의 분포를 볼 수 있습니다. 평균이 가장 높은 부서는 마켓팅, 다음은 finance, IT, HR순서로 볼 수 있습니다. 또한 상대적으로 마케팅, 파이낸스, 아이티 부서는 분산이 골고루 퍼져 있는 것으로 보이며, HR의 경우, 비교적 좁은 범위에 월급이 분포되어 있고, 특이점도 볼 수 있습니다. 



(i)	사용자 정의 함수 my_percentile()를 작성하시오. 이 함수는 벡터와 백분위수를 입력받아 해당 백분위수에 해당하는 값을 반환해야 한다. (반드시 if문을 쓰시오.)

```{r}


# 사용자 정의 함수 my_percentile() 정의
my_percentile <- function(vec, percentile) {
  # 입력된 백분위수가 0과 100 사이인지 확인
  if (percentile < 0 || percentile > 100) {
    stop("백분위수는 0과 100 사이여야 합니다.")
  }
  
  # 벡터의 길이 계산
  n <- length(vec)
  
  # 벡터를 오름차순으로 정렬
  sorted_vec <- sort(vec)
  
  # 백분위수에 해당하는 위치 계산
  rank <- percentile / 100 * (n - 1) + 1
  
  # 정수 부분과 소수 부분 구분
  lower_rank <- floor(rank)
  upper_rank <- ceiling(rank)
  
  # 만약 백분위수가 정수 위치에 해당하면, 그 값을 반환
  if (lower_rank == upper_rank) {
    return(sorted_vec[lower_rank])
  } else {
    # 백분위수에 해당하는 값을 두 위치의 가중 평균으로 계산
    return(sorted_vec[lower_rank] + (rank - lower_rank) * (sorted_vec[upper_rank] - sorted_vec[lower_rank]))
  }
}

# 예시로 함수 사용하기
vec <- c(5, 8, 12, 20, 25, 30)
percentile_50 <- my_percentile(vec, 50)  # 50번째 백분위수
percentile_25 <- my_percentile(vec, 25)  # 25번째 백분위수

# 출력
percentile_50
percentile_25

```


(j)	위에서 작성한 my_percentile() 함수를 사용하여 salaries에서 25번째, 50번째(중위수), 75번째 백분위수를 구하시오.

```{r}

my_percentile(employee_data$salaries,25)
my_percentile(employee_data$salaries,50)
my_percentile(employee_data$salaries,75)

```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
